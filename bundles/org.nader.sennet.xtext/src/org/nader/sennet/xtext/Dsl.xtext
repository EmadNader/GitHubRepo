// automatically generated by Xtext
grammar org.nader.sennet.xtext.Dsl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore" as sennet
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//job" as job
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//node" as node
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//enums" as enums
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//network" as network
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//sensors" as sensors
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//job/jobaction" as jobaction
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//job/jobtrigger" as jobtrigger
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//toplevelstructure" as toplevelstructure

SeNetApp returns sennet::SeNetApp:
	{sennet::SeNetApp}
	'SeNetApp'
	name=EString
	'{'
		('id' id=EInt)?
		('jobs' '{' jobs+=AbstractJob ( "," jobs+=AbstractJob)* '}' )?
	'}';

AbstractJob returns job::AbstractJob:
	SenseForwardJob | AggregationJob | FusionJob | SenseNowJob | SinkJob | RegularSenseJob;

AbstractNode returns node::AbstractNode:
	SensorNode | ClusterHeadNode | SinkNode | ComputationNode;

AbstractNetwork returns network::AbstractNetwork:
	FlatNetwork | ClusteredNetwork;

AbstractStartEndingJobTrigger returns jobtrigger::AbstractStartEndingJobTrigger:
	ReceiveMessageTrigger | RecieveSerialMsgTrigger | StartJobTrigger_Impl | StopJobTrigger_Impl | PushButtomTrigger;

AbstratAction returns jobaction::AbstratAction:
	ReadNodeMemoryAction | WriteNodeMemoryAction | SendMessageAction | BlinkAction | SendSerialPortMsgAction;

AbstractSensor returns sensors::AbstractSensor:
	AccelerometerSensor | LightSensor | LocationSensor | MicrophoneSensor | TemperatureSensor | PressureSensor | HumiditySensor | VoltageSensor;


AbstractFlatNode returns node::AbstractFlatNode:
	SensorNode | ComputationNode;


AbstractClusterNode returns node::AbstractClusterNode:
	SensorNode | ClusterHeadNode;


EInt returns ecore::EInt:
	'-'? INT;

EString returns ecore::EString:
	STRING | ID;

SenseForwardJob returns job::SenseForwardJob:
	{job::SenseForwardJob}
	'SenseForwardJob'
	'{'
		('id' id=EInt)?
		('sensingThreshold' sensingThreshold=ELong)?
		('JobTargetNode' JobTargetNode=AbstractNode)?
		('JobTargetNetwork' JobTargetNetwork=AbstractNetwork)?
		('startEndTrigger' '{' startEndTrigger+=AbstractStartEndingJobTrigger ( "," startEndTrigger+=AbstractStartEndingJobTrigger)* '}' )?
		('jobaction' '{' jobaction+=AbstratAction ( "," jobaction+=AbstratAction)* '}' )?
	'}';

AggregationJob returns job::AggregationJob:
	{job::AggregationJob}
	'AggregationJob'
	'{'
		('id' id=EInt)?
		('aggregation' aggregation=Aggregation)?
		('JobTargetNode' JobTargetNode=AbstractNode)?
		('JobTargetNetwork' JobTargetNetwork=AbstractNetwork)?
		('startEndTrigger' '{' startEndTrigger+=AbstractStartEndingJobTrigger ( "," startEndTrigger+=AbstractStartEndingJobTrigger)* '}' )?
		('jobaction' '{' jobaction+=AbstratAction ( "," jobaction+=AbstratAction)* '}' )?
	'}';

FusionJob returns job::FusionJob:
	{job::FusionJob}
	'FusionJob'
	'{'
		('id' id=EInt)?
		('fusion' fusion=Fusion)?
		('JobTargetNode' JobTargetNode=AbstractNode)?
		('JobTargetNetwork' JobTargetNetwork=AbstractNetwork)?
		('startEndTrigger' '{' startEndTrigger+=AbstractStartEndingJobTrigger ( "," startEndTrigger+=AbstractStartEndingJobTrigger)* '}' )?
		('jobaction' '{' jobaction+=AbstratAction ( "," jobaction+=AbstratAction)* '}' )?
	'}';

SenseNowJob returns job::SenseNowJob:
	{job::SenseNowJob}
	'SenseNowJob'
	'{'
		('id' id=EInt)?
		('JobTargetNode' JobTargetNode=AbstractNode)?
		('JobTargetNetwork' JobTargetNetwork=AbstractNetwork)?
		('startEndTrigger' '{' startEndTrigger+=AbstractStartEndingJobTrigger ( "," startEndTrigger+=AbstractStartEndingJobTrigger)* '}' )?
		('jobaction' '{' jobaction+=AbstratAction ( "," jobaction+=AbstratAction)* '}' )?
	'}';

SinkJob returns job::SinkJob:
	{job::SinkJob}
	'SinkJob'
	'{'
		('id' id=EInt)?
		('JobTargetNode' JobTargetNode=AbstractNode)?
		('JobTargetNetwork' JobTargetNetwork=AbstractNetwork)?
		('startEndTrigger' '{' startEndTrigger+=AbstractStartEndingJobTrigger ( "," startEndTrigger+=AbstractStartEndingJobTrigger)* '}' )?
		('jobaction' '{' jobaction+=AbstratAction ( "," jobaction+=AbstratAction)* '}' )?
	'}';

RegularSenseJob returns job::RegularSenseJob:
	{job::RegularSenseJob}
	'RegularSenseJob'
	'{'
		('id' id=EInt)?
		('sensingThreshold' sensingThreshold=ELong)?
		('JobTargetNode' JobTargetNode=AbstractNode)?
		('JobTargetNetwork' JobTargetNetwork=AbstractNetwork)?
		('startEndTrigger' '{' startEndTrigger+=AbstractStartEndingJobTrigger ( "," startEndTrigger+=AbstractStartEndingJobTrigger)* '}' )?
		('jobaction' '{' jobaction+=AbstratAction ( "," jobaction+=AbstratAction)* '}' )?
	'}';

enum Position returns enums::Position:
				mobile = 'mobile' | static = 'static';

SensorNode returns node::SensorNode:
	{node::SensorNode}
	'SensorNode'
	'{'
		('id' id=EInt)?
		('position' position=Position)?
		('nodeResources' '{' nodeResources+=AbstractSensor ( "," nodeResources+=AbstractSensor)* '}' )?
	'}';

ClusterHeadNode returns node::ClusterHeadNode:
	{node::ClusterHeadNode}
	'ClusterHeadNode'
	'{'
		('id' id=EInt)?
		('position' position=Position)?
		('nodeResources' '{' nodeResources+=AbstractSensor ( "," nodeResources+=AbstractSensor)* '}' )?
	'}';

SinkNode returns node::SinkNode:
	{node::SinkNode}
	'SinkNode'
	'{'
		('id' id=EInt)?
		('position' position=Position)?
		('nodeResources' '{' nodeResources+=AbstractSensor ( "," nodeResources+=AbstractSensor)* '}' )?
	'}';

ComputationNode returns node::ComputationNode:
	{node::ComputationNode}
	'ComputationNode'
	'{'
		('id' id=EInt)?
		('position' position=Position)?
		('nodeResources' '{' nodeResources+=AbstractSensor ( "," nodeResources+=AbstractSensor)* '}' )?
	'}';

AccelerometerSensor returns sensors::AccelerometerSensor:
	{sensors::AccelerometerSensor}
	'AccelerometerSensor'
	;

LightSensor returns sensors::LightSensor:
	{sensors::LightSensor}
	'LightSensor'
	;

LocationSensor returns sensors::LocationSensor:
	{sensors::LocationSensor}
	'LocationSensor'
	;

MicrophoneSensor returns sensors::MicrophoneSensor:
	{sensors::MicrophoneSensor}
	'MicrophoneSensor'
	;

TemperatureSensor returns sensors::TemperatureSensor:
	{sensors::TemperatureSensor}
	'TemperatureSensor'
	;

PressureSensor returns sensors::PressureSensor:
	{sensors::PressureSensor}
	'PressureSensor'
	;

HumiditySensor returns sensors::HumiditySensor:
	{sensors::HumiditySensor}
	'HumiditySensor'
	;

VoltageSensor returns sensors::VoltageSensor:
	{sensors::VoltageSensor}
	'VoltageSensor'
	;

enum InterNodeComm returns enums::InterNodeComm:
				BT = 'BT' | Zigbee = 'Zigbee' | WLan = 'WLan' | RF = 'RF';

enum RoutingProtocol returns enums::RoutingProtocol:
				leach = 'leach' | lqrp = 'lqrp' | spin = 'spin' | aodv = 'aodv' | dodv = 'dodv' | dsr = 'dsr' | dsdv = 'dsdv' | gsr = 'gsr' | heed = 'heed' | gaf = 'gaf' | gear = 'gear' | tbf = 'tbf' | ead = 'ead' | pegasis = 'pegasis' | teen = 'teen' | speed = 'speed' | ctp = 'ctp' | dismentation = 'dismentation' | activeMessage = 'activeMessage';

FlatNetwork returns network::FlatNetwork:
	'FlatNetwork'
	'{'
		('id' id=EInt)?
		('nbOfNodes' nbOfNodes=EInt)?
		('interNodeComm' interNodeComm=InterNodeComm)?
		('routingProtocol' routingProtocol=RoutingProtocol)?
		('resources' '{' resources+=AbstractSensor ( "," resources+=AbstractSensor)* '}' )?
		'sink' sink=SinkNode
		('nodes' '{' nodes+=AbstractFlatNode ( "," nodes+=AbstractFlatNode)* '}' )?
	'}';

ClusteredNetwork returns network::ClusteredNetwork:
	'ClusteredNetwork'
	'{'
		('id' id=EInt)?
		('nbOfNodes' nbOfNodes=EInt)?
		('interNodeComm' interNodeComm=InterNodeComm)?
		('routingProtocol' routingProtocol=RoutingProtocol)?
		('resources' '{' resources+=AbstractSensor ( "," resources+=AbstractSensor)* '}' )?
		'sink' sink=SinkNode
		('clusters' '{' clusters+=Cluster ( "," clusters+=Cluster)* '}' )?
	'}';

Cluster returns network::Cluster:
	{network::Cluster}
	'Cluster'
	'{'
		('id' id=EInt)?
		('resources' '(' resources+=[sensors::AbstractSensor|EString] ( "," resources+=[sensors::AbstractSensor|EString])* ')' )?
		('nodes' '{' nodes+=AbstractClusterNode ( "," nodes+=AbstractClusterNode)* '}' )?
	'}';

ReceiveMessageTrigger returns jobtrigger::ReceiveMessageTrigger:
	{jobtrigger::ReceiveMessageTrigger}
	'ReceiveMessageTrigger'
	;

RecieveSerialMsgTrigger returns jobtrigger::RecieveSerialMsgTrigger:
	{jobtrigger::RecieveSerialMsgTrigger}
	'RecieveSerialMsgTrigger'
	;

StartJobTrigger_Impl returns jobtrigger::StartJobTrigger:
	{jobtrigger::StartJobTrigger}
	'StartJobTrigger'
	;

StopJobTrigger_Impl returns jobtrigger::StopJobTrigger:
	{jobtrigger::StopJobTrigger}
	'StopJobTrigger'
	;

PushButtomTrigger returns jobtrigger::PushButtomTrigger:
	{jobtrigger::PushButtomTrigger}
	'PushButtomTrigger'
	;

ConditionalAction returns jobaction::ConditionalAction:
	{jobaction::ConditionalAction}
	'ConditionalAction'
	'{'
		('sensorTerm' sensorTerm=EString)?
		('logicalSymbol' logicalSymbol=LogicalSymbol)?
		('value' value=ELong)?
		('unit' unit=EString)?
	'}';

ReadNodeMemoryAction returns jobaction::ReadNodeMemoryAction:
	'ReadNodeMemoryAction'
	'{'
		'condition' condition=ConditionalAction
	'}';

WriteNodeMemoryAction returns jobaction::WriteNodeMemoryAction:
	'WriteNodeMemoryAction'
	'{'
		'condition' condition=ConditionalAction
	'}';

SendMessageAction returns jobaction::SendMessageAction:
	'SendMessageAction'
	'{'
		('sendMessageTo' sendMessageTo=EInt)?
		'condition' condition=ConditionalAction
	'}';

BlinkAction returns jobaction::BlinkAction:
	'BlinkAction'
	'{'
		('led' led=Leds)?
		('status' status=LedStatus)?
		'condition' condition=ConditionalAction
	'}';

SendSerialPortMsgAction returns jobaction::SendSerialPortMsgAction:
	'SendSerialPortMsgAction'
	'{'
		'condition' condition=ConditionalAction
	'}';

enum LogicalSymbol returns enums::LogicalSymbol:
				equal = 'equal' | greaterThan = 'greaterThan' | greaterOrEqualThan = 'greaterOrEqualThan' | lessThan = 'lessThan' | lessOrEqualThan = 'lessOrEqualThan' | notEqual = 'notEqual';

ELong returns ecore::ELong:
	'-'? INT;

enum Leds returns enums::Leds:
				led0 = 'led0' | led1 = 'led1' | led2 = 'led2';

enum LedStatus returns enums::LedStatus:
				on = 'on' | off = 'off' | toggle = 'toggle';

enum Aggregation returns enums::Aggregation:
				filtering = 'filtering' | compression = 'compression' | max = 'max' | min = 'min' | avg = 'avg' | count = 'count';

enum Fusion returns enums::Fusion:
				classification = 'classification' | event_detection = 'event_detection' | tracking = 'tracking' | decision_making = 'decision_making';
