// automatically generated by Xtext
grammar org.nader.sennet.xtext.SNDsl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore"	
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//network" as network
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//job" as job
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//enums" as enums
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//node" as node
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//toplevelstructure" as toplevelstructure
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//sensor" as sensor
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//job/actions" as actions
import "platform:/resource/org.nader.sennet.model/model/SenNet.ecore#//port" as port

WSNapp returns WSNapp:
	{WSNapp}
	'WSNapp'
	name=EString
	'{'
		('id' id=EInt)?
		('network' network=AbstractNetwork)?
		('jobs' '{' jobs+=AbstractJob ( "," jobs+=AbstractJob)* '}' )?
	'}';

AbstractNetwork returns network::AbstractNetwork:
	FlatNetwork | ClusteredNetwork;

AbstractJob returns job::AbstractJob:
	ContinuousJob | EventDrivenJob | PeriodicJob | RequestReplayJob;

AbstractPort returns port::AbstractPort:
	UsbPort | SerialPort | OutPort_Impl | InPort_Impl | Transmitter | Reciever;

AbstractSensor returns sensor::AbstractSensor:
	AccelerometerSensor | LightSensor | LocationSensor | MicrophoneSensor | TemperatureSensor | PressureSensor | HumiditySensor | ChemicalSensor;


AbstractFlatNode returns node::AbstractFlatNode:
	SensorNode | ComputationNode;



AbstractClusterNode returns node::AbstractClusterNode:
	SensorNode | ClusterHeadNode;


AbstractJobAction returns actions::AbstractJobAction:
	SenseForwardAction | AggregationAction | FusionAction | ReadNodeMemoryAction | WriteNodeMemoryAction | SendMessageAction | ReceiveMessageAction;


AbstractNode returns node::AbstractNode:
	SensorNode | ClusterHeadNode | SinkNode | ComputationNode;


OutPort returns port::OutPort:
	OutPort_Impl | UsbPort | SerialPort | Transmitter;

InPort returns port::InPort:
	InPort_Impl | UsbPort | SerialPort | Reciever;

EInt returns ecore::EInt:
	'-'? INT;

EString returns ecore::EString:
	STRING | ID;

enum InterNodeComm returns enums::InterNodeComm:
				BT = 'BT' | Zigbee = 'Zigbee' | WLan = 'WLan' | RF = 'RF';

enum RoutingProtocol returns enums::RoutingProtocol:
				leach = 'leach' | lqrp = 'lqrp' | spin = 'spin' | aodv = 'aodv' | dodv = 'dodv' | dsr = 'dsr' | dsdv = 'dsdv' | gsr = 'gsr' | heed = 'heed' | gaf = 'gaf' | gear = 'gear' | tbf = 'tbf' | ead = 'ead' | pegasis = 'pegasis' | teen = 'teen' | speed = 'speed';

SinkNode returns node::SinkNode:
	{node::SinkNode}
	'SinkNode'
	'{'
		('id' id=EInt)?
		('position' position=Position)?
		('ports' '(' ports+=[port::AbstractPort|EString] ( "," ports+=[port::AbstractPort|EString])* ')' )?
		('sensors' '(' sensors+=[sensor::AbstractSensor|EString] ( "," sensors+=[sensor::AbstractSensor|EString])* ')' )?
	'}';

FlatNetwork returns network::FlatNetwork:
	{network::FlatNetwork}
	'FlatNetwork'
	'{'
		('id' id=EInt)?
		('nbOfNodes' nbOfNodes=EInt)?
		('interNodeComm' interNodeComm=InterNodeComm)?
		('routingProtocol' routingProtocol=RoutingProtocol)?
		('sink' sink=[node::SinkNode|EString])?
		('sensors' '{' sensors+=AbstractSensor ( "," sensors+=AbstractSensor)* '}' )?
		('ports' '{' ports+=AbstractPort ( "," ports+=AbstractPort)* '}' )?
		('nodes' '{' nodes+=AbstractFlatNode ( "," nodes+=AbstractFlatNode)* '}' )?
	'}';

ClusteredNetwork returns network::ClusteredNetwork:
	{network::ClusteredNetwork}
	'ClusteredNetwork'
	'{'
		('id' id=EInt)?
		('nbOfNodes' nbOfNodes=EInt)?
		('interNodeComm' interNodeComm=InterNodeComm)?
		('routingProtocol' routingProtocol=RoutingProtocol)?
		('sink' sink=[node::SinkNode|EString])?
		('sensors' '{' sensors+=AbstractSensor ( "," sensors+=AbstractSensor)* '}' )?
		('ports' '{' ports+=AbstractPort ( "," ports+=AbstractPort)* '}' )?
		('clusters' '{' clusters+=Cluster ( "," clusters+=Cluster)* '}' )?
	'}';

enum Position returns enums::Position:
				mobile = 'mobile' | static = 'static';

AccelerometerSensor returns sensor::AccelerometerSensor:
	{sensor::AccelerometerSensor}
	'AccelerometerSensor'
	;

LightSensor returns sensor::LightSensor:
	{sensor::LightSensor}
	'LightSensor'
	;

LocationSensor returns sensor::LocationSensor:
	{sensor::LocationSensor}
	'LocationSensor'
	;

MicrophoneSensor returns sensor::MicrophoneSensor:
	{sensor::MicrophoneSensor}
	'MicrophoneSensor'
	;

TemperatureSensor returns sensor::TemperatureSensor:
	{sensor::TemperatureSensor}
	'TemperatureSensor'
	;

PressureSensor returns sensor::PressureSensor:
	{sensor::PressureSensor}
	'PressureSensor'
	;

HumiditySensor returns sensor::HumiditySensor:
	{sensor::HumiditySensor}
	'HumiditySensor'
	;

ChemicalSensor returns sensor::ChemicalSensor:
	{sensor::ChemicalSensor}
	'ChemicalSensor'
	;

UsbPort returns port::UsbPort:
	{port::UsbPort}
	'UsbPort'
	;

SerialPort returns port::SerialPort:
	{port::SerialPort}
	'SerialPort'
	;

OutPort_Impl returns port::OutPort:
	{port::OutPort}
	'OutPort'
	;

InPort_Impl returns port::InPort:
	{port::InPort}
	'InPort'
	;

Transmitter returns port::Transmitter:
	{port::Transmitter}
	'Transmitter'
	;

Reciever returns port::Reciever:
	{port::Reciever}
	'Reciever'
	;

SensorNode returns node::SensorNode:
	{node::SensorNode}
	'SensorNode'
	'{'
		('id' id=EInt)?
		('position' position=Position)?
		('ports' '(' ports+=[port::AbstractPort|EString] ( "," ports+=[port::AbstractPort|EString])* ')' )?
		('sensors' '(' sensors+=[sensor::AbstractSensor|EString] ( "," sensors+=[sensor::AbstractSensor|EString])* ')' )?
	'}';

ComputationNode returns node::ComputationNode:
	{node::ComputationNode}
	'ComputationNode'
	'{'
		('id' id=EInt)?
		('position' position=Position)?
		('ports' '(' ports+=[port::AbstractPort|EString] ( "," ports+=[port::AbstractPort|EString])* ')' )?
		('sensors' '(' sensors+=[sensor::AbstractSensor|EString] ( "," sensors+=[sensor::AbstractSensor|EString])* ')' )?
	'}';

Cluster returns network::Cluster:
	{network::Cluster}
	'Cluster'
	'{'
		('id' id=EInt)?
		('resources' '(' resources+=[toplevelstructure::AbstractResource|EString] ( "," resources+=[toplevelstructure::AbstractResource|EString])* ')' )?
		('head' head=ClusterHeadNode)?
		('nodes' '{' nodes+=AbstractClusterNode ( "," nodes+=AbstractClusterNode)* '}' )?
	'}';

ClusterHeadNode returns node::ClusterHeadNode:
	{node::ClusterHeadNode}
	'ClusterHeadNode'
	'{'
		('id' id=EInt)?
		('position' position=Position)?
		('ports' '(' ports+=[port::AbstractPort|EString] ( "," ports+=[port::AbstractPort|EString])* ')' )?
		('sensors' '(' sensors+=[sensor::AbstractSensor|EString] ( "," sensors+=[sensor::AbstractSensor|EString])* ')' )?
	'}';

ContinuousJob returns job::ContinuousJob:
	{job::ContinuousJob}
	'ContinuousJob'
	'{'
		('id' id=EInt)?
		('action' action=AbstractJobAction)?
	'}';

EventDrivenJob returns job::EventDrivenJob:
	{job::EventDrivenJob}
	'EventDrivenJob'
	'{'
		('id' id=EInt)?
		('action' action=AbstractJobAction)?
		('eventCondition' eventCondition=LogicalCondition)?
	'}';

PeriodicJob returns job::PeriodicJob:
	{job::PeriodicJob}
	'PeriodicJob'
	'{'
		('id' id=EInt)?
		('timer' timer=ELong)?
		('action' action=AbstractJobAction)?
	'}';

RequestReplayJob returns job::RequestReplayJob:
	{job::RequestReplayJob}
	'RequestReplayJob'
	'{'
		('id' id=EInt)?
		('action' action=AbstractJobAction)?
	'}';

SenseForwardAction returns actions::SenseForwardAction:
	{actions::SenseForwardAction}
	'SenseForwardAction'
	'{'
		('sinkNode' sinkNode=[node::SinkNode|EString])?
		('targetNode' targetNode=[node::AbstractNode|EString])?
	'}';

AggregationAction returns actions::AggregationAction:
	{actions::AggregationAction}
	'AggregationAction'
	'{'
		('aggregation' aggregation=Aggregation)?
		('sinkNode' sinkNode=[node::SinkNode|EString])?
		('targetNode' targetNode=[node::AbstractNode|EString])?
	'}';

FusionAction returns actions::FusionAction:
	{actions::FusionAction}
	'FusionAction'
	'{'
		('fusion' fusion=Fusion)?
		('sinkNode' sinkNode=[node::SinkNode|EString])?
		('compuNode' compuNode=[node::ComputationNode|EString])?
		('clusterHead' clusterHead=[node::ClusterHeadNode|EString])?
	'}';

ReadNodeMemoryAction returns actions::ReadNodeMemoryAction:
	{actions::ReadNodeMemoryAction}
	'ReadNodeMemoryAction'
	'{'
		('sinkNode' sinkNode=[node::SinkNode|EString])?
		('targetNode' targetNode=[node::AbstractNode|EString])?
	'}';

WriteNodeMemoryAction returns actions::WriteNodeMemoryAction:
	{actions::WriteNodeMemoryAction}
	'WriteNodeMemoryAction'
	'{'
		('sinkNode' sinkNode=[node::SinkNode|EString])?
		('targetNode' targetNode=[node::AbstractNode|EString])?
	'}';

SendMessageAction returns actions::SendMessageAction:
	{actions::SendMessageAction}
	'SendMessageAction'
	'{'
		('text' text=EString)?
		('sinkNode' sinkNode=[node::SinkNode|EString])?
		('targetNode' targetNode=[node::AbstractNode|EString])?
		('outPort' outPort=[port::OutPort|EString])?
	'}';

ReceiveMessageAction returns actions::ReceiveMessageAction:
	{actions::ReceiveMessageAction}
	'ReceiveMessageAction'
	'{'
		('sinkNode' sinkNode=[node::SinkNode|EString])?
		('targetNode' targetNode=[node::AbstractNode|EString])?
		('inPort' inPort=[port::InPort|EString])?
	'}';

enum Aggregation returns enums::Aggregation:
				filtering = 'filtering' | compression = 'compression' | max = 'max' | min = 'min' | avg = 'avg' | count = 'count';

enum Fusion returns enums::Fusion:
				classification = 'classification' | event_detection = 'event_detection' | tracking = 'tracking' | decision_making = 'decision_making';

LogicalCondition returns LogicalCondition:
	{LogicalCondition}
	'LogicalCondition'
	'{'
		('jobSchedule' jobSchedule=JobSchedule)?
		('sensorTerm' sensorTerm=EString)?
		('logicalSymbol' logicalSymbol=LogicalSymbol)?
		('value' value=ELong)?
		('unit' unit=EString)?
	'}';

enum JobSchedule returns enums::JobSchedule:
				start = 'start' | stop = 'stop';

enum LogicalSymbol returns enums::LogicalSymbol:
				equal = 'equal' | greaterThan = 'greaterThan' | greaterOrEqualThan = 'greaterOrEqualThan' | lessThan = 'lessThan' | lessOrEqualThan = 'lessOrEqualThan' | not = 'not';

ELong returns ecore::ELong:
	'-'? INT;
